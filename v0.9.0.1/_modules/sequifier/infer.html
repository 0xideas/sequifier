<!doctype html>
<html class="no-js" lang="en" data-content_root="../../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html"><link rel="search" title="Search" href="../../search.html">
        <link rel="canonical" href="https://www.sequifier.com/_modules/sequifier/infer.html">

    <!-- Generated with Sphinx 8.2.3 and Furo 2025.09.25 -->
        <title>sequifier.infer - sequifier v0.9.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d111a655" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=8dab3a3b" />
    
    


<style>
  body {
    --color-code-background: #f2f2f2;
  --color-code-foreground: #1e1e1e;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">sequifier v0.9.0.1 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  <span class="sidebar-brand-text">sequifier v0.9.0.1 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Preprocessing Config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html#module-sequifier.config.train_config">Training Config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html#module-sequifier.config.infer_config">Inference Config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html#module-sequifier.config.hyperparameter_search_config">Hyperparameter Search Config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html#module-sequifier.optimizers.ademamix">Non-standard Optimizers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html#module-sequifier.sequifier">Internals</a></li>
</ul>

</div>
<div class="sidebar-tree">
  <p class="caption" role="heading">
    <span class="caption-text">Versions</span>
  </p>
  <ul>
      <li><a href="../../../main/index.html">main</a></li>
      <li><a href="../../../v0.8.0.10/index.html">v0.8.0.10</a></li>
      <li><a href="../../../v0.8.0.7/index.html">v0.8.0.7</a></li>
      <li><a href="../../../v0.8.0.8/index.html">v0.8.0.8</a></li>
      <li><a href="../../../v0.8.0.9/index.html">v0.8.0.9</a></li>
      <li><a href="../../../v0.8.1.0/index.html">v0.8.1.0</a></li>
      <li><a href="../../../v0.9.0.0/index.html">v0.9.0.0</a></li>
      <li><a href="infer.html">v0.9.0.1</a></li>
      <li><a href="../../../v0.9.0.2/index.html">v0.9.0.2</a></li>
      <li><a href="../../../v0.9.0.3/index.html">v0.9.0.3</a></li>
      <li><a href="../../../v0.9.0.4/index.html">v0.9.0.4</a></li>
      <li><a href="../../../v0.9.1.0/index.html">v0.9.1.0</a></li>
      <li><a href="../../../v1.0.0.0/index.html">v1.0.0.0</a></li>
      <li><a href="../../../v1.0.0.1/index.html">v1.0.0.1</a></li>
  </ul>
</div>
</div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for sequifier.infer</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">onnxruntime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">polars</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pl</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">beartype</span><span class="w"> </span><span class="kn">import</span> <span class="n">beartype</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">sequifier.config.infer_config</span><span class="w"> </span><span class="kn">import</span> <span class="n">InfererModel</span><span class="p">,</span> <span class="n">load_inferer_config</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sequifier.helpers</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">PANDAS_TO_TORCH_TYPES</span><span class="p">,</span>
    <span class="n">construct_index_maps</span><span class="p">,</span>
    <span class="n">normalize_path</span><span class="p">,</span>
    <span class="n">numpy_to_pytorch</span><span class="p">,</span>
    <span class="n">subset_to_selected_columns</span><span class="p">,</span>
    <span class="n">write_data</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sequifier.train</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">infer_with_embedding_model</span><span class="p">,</span>
    <span class="n">infer_with_generative_model</span><span class="p">,</span>
    <span class="n">load_inference_model</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="infer">
<a class="viewcode-back" href="../../api.html#sequifier.infer.infer">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">infer</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">args_config</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Runs the main inference pipeline.</span>

<span class="sd">    This function orchestrates the inference process. It loads the main</span>
<span class="sd">    inference configuration, retrieves necessary metadata like ID maps and</span>
<span class="sd">    column statistics from a `ddconfig` file (if required for mapping or</span>
<span class="sd">    normalization), and then delegates the core work to the `infer_worker`</span>
<span class="sd">    function.</span>

<span class="sd">    Args:</span>
<span class="sd">        args: Command-line arguments, typically from `argparse`. Expected</span>
<span class="sd">            to have attributes like `config_path` and `on_unprocessed`.</span>
<span class="sd">        args_config: A dictionary of configuration overrides, often</span>
<span class="sd">            passed from the command line, that will be merged into the</span>
<span class="sd">            loaded configuration file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--- Starting Inference ---&quot;</span><span class="p">)</span>
    <span class="n">config_path</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">args</span><span class="o">.</span><span class="n">config_path</span> <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">config_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;configs/infer.yaml&quot;</span>
    <span class="p">)</span>

    <span class="n">config</span> <span class="o">=</span> <span class="n">load_inferer_config</span><span class="p">(</span><span class="n">config_path</span><span class="p">,</span> <span class="n">args_config</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">on_unprocessed</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">map_to_id</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">real_columns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">config</span><span class="o">.</span><span class="n">ddconfig_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;If you want to map to id, you need to provide a file path to a json that contains: {{&#39;id_maps&#39;:{...}}} to ddconfig_path&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">If you have real columns in the data, you need to provide a json that contains: {{&#39;selected_columns_statistics&#39;:{COL_NAME:{&#39;std&#39;:..., &#39;mean&#39;:...}}}}&quot;</span>
        <span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">normalize_path</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">ddconfig_path</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">project_path</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">dd_config</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
            <span class="n">id_maps</span> <span class="o">=</span> <span class="n">dd_config</span><span class="p">[</span><span class="s2">&quot;id_maps&quot;</span><span class="p">]</span>
            <span class="n">selected_columns_statistics</span> <span class="o">=</span> <span class="n">dd_config</span><span class="p">[</span><span class="s2">&quot;selected_columns_statistics&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">id_maps</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">selected_columns_statistics</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">infer_worker</span><span class="p">(</span>
        <span class="n">config</span><span class="p">,</span> <span class="n">args_config</span><span class="p">,</span> <span class="n">id_maps</span><span class="p">,</span> <span class="n">selected_columns_statistics</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="load_pt_dataset">
<a class="viewcode-back" href="../../api.html#sequifier.infer.load_pt_dataset">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">load_pt_dataset</span><span class="p">(</span><span class="n">data_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">start_pct</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">end_pct</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Lazily loads and yields data from .pt files in a directory.</span>

<span class="sd">    This function scans a directory for `.pt` files, sorts them, and then</span>
<span class="sd">    yields the contents of a specific slice of those files defined by a</span>
<span class="sd">    start and end percentage. This allows for processing large datasets</span>
<span class="sd">    in chunks without loading everything into memory.</span>

<span class="sd">    Args:</span>
<span class="sd">        data_path: The path to the folder containing the `.pt` files.</span>
<span class="sd">        start_pct: The starting percentage (0.0 to 100.0) of the file list</span>
<span class="sd">            to begin loading from.</span>
<span class="sd">        end_pct: The ending percentage (0.0 to 100.0) of the file list</span>
<span class="sd">            to stop loading at.</span>

<span class="sd">    Yields:</span>
<span class="sd">        Iterator: An iterator where each item is the data loaded from a</span>
<span class="sd">        single `.pt` file (e.g., using `torch.load`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get all .pt files in the directory (not nested)</span>
    <span class="n">pt_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">data_path</span><span class="p">)</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.pt&quot;</span><span class="p">))</span>

    <span class="c1"># Calculate slice indices</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pt_files</span><span class="p">)</span>
    <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">total</span> <span class="o">*</span> <span class="n">start_pct</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">total</span> <span class="o">*</span> <span class="n">end_pct</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>

    <span class="c1"># Lazily load and yield data from files in range</span>
    <span class="k">for</span> <span class="n">pt_file</span> <span class="ow">in</span> <span class="n">pt_files</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]:</span>
        <span class="k">yield</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pt_file</span><span class="p">)</span></div>



<div class="viewcode-block" id="infer_worker">
<a class="viewcode-back" href="../../api.html#sequifier.infer.infer_worker">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">infer_worker</span><span class="p">(</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">args_config</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">id_maps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span>
    <span class="n">selected_columns_statistics</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
    <span class="n">percentage_limits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Core worker function that performs inference.</span>

<span class="sd">    This function handles the main workflow:</span>
<span class="sd">    1. Loads the dataset based on `config.read_format` (parquet, csv, or pt).</span>
<span class="sd">    2. Iterates over one or more model paths specified in the config.</span>
<span class="sd">    3. For each model, initializes an `Inferer` object with all necessary</span>
<span class="sd">       configurations, mappings, and statistics.</span>
<span class="sd">    4. Calls the appropriate inference function (`infer_generative` or</span>
<span class="sd">       `infer_embedding`) based on the `config.model_type`.</span>
<span class="sd">    5. Manages the data iterators and passes data chunks to the</span>
<span class="sd">       inference functions.</span>

<span class="sd">    Args:</span>
<span class="sd">        config: The fully resolved `InfererModel` configuration object.</span>
<span class="sd">        args_config: A dictionary of command-line arguments, passed to the</span>
<span class="sd">            `Inferer` for potential model loading overrides.</span>
<span class="sd">        id_maps: A nested dictionary mapping categorical column names to</span>
<span class="sd">            their value-to-index maps. `None` if `map_to_id` is False.</span>
<span class="sd">        selected_columns_statistics: A nested dictionary containing &#39;mean&#39;</span>
<span class="sd">            and &#39;std&#39; for real-valued columns used for normalization.</span>
<span class="sd">        percentage_limits: A tuple (start_pct, end_pct) used only when</span>
<span class="sd">            `config.read_format == &quot;pt&quot;` to slice the dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Reading data from &#39;</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">data_path</span><span class="si">}</span><span class="s2">&#39;...&quot;</span><span class="p">)</span>
    <span class="c1"># Step 1: Use Polars for data ingestion</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">read_format</span> <span class="o">==</span> <span class="s2">&quot;parquet&quot;</span><span class="p">:</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span><span class="n">pl</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">data_path</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">config</span><span class="o">.</span><span class="n">read_format</span> <span class="o">==</span> <span class="s2">&quot;csv&quot;</span><span class="p">:</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span><span class="n">pl</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">data_path</span><span class="p">)]</span>

    <span class="n">model_paths</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">config</span><span class="o">.</span><span class="n">model_path</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">model_path</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">[</span><span class="n">config</span><span class="o">.</span><span class="n">model_path</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">model_path</span> <span class="ow">in</span> <span class="n">model_paths</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">read_format</span> <span class="o">==</span> <span class="s2">&quot;pt&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">percentage_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">start_pct</span><span class="p">,</span> <span class="n">end_pct</span> <span class="o">=</span> <span class="n">percentage_limits</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">load_pt_dataset</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">data_path</span><span class="p">,</span> <span class="n">start_pct</span><span class="p">,</span> <span class="n">end_pct</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dataset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">read_format</span><span class="w"> </span><span class="si">= }</span><span class="s2"> not in [&#39;parquet&#39;, &#39;csv&#39;, &#39;pt&#39;]&quot;</span><span class="p">)</span>

        <span class="n">inferer</span> <span class="o">=</span> <span class="n">Inferer</span><span class="p">(</span>
            <span class="n">config</span><span class="o">.</span><span class="n">model_type</span><span class="p">,</span>
            <span class="n">model_path</span><span class="p">,</span>
            <span class="n">config</span><span class="o">.</span><span class="n">project_path</span><span class="p">,</span>
            <span class="n">id_maps</span><span class="p">,</span>
            <span class="n">selected_columns_statistics</span><span class="p">,</span>
            <span class="n">config</span><span class="o">.</span><span class="n">map_to_id</span><span class="p">,</span>
            <span class="n">config</span><span class="o">.</span><span class="n">categorical_columns</span><span class="p">,</span>
            <span class="n">config</span><span class="o">.</span><span class="n">real_columns</span><span class="p">,</span>
            <span class="n">config</span><span class="o">.</span><span class="n">selected_columns</span><span class="p">,</span>
            <span class="n">config</span><span class="o">.</span><span class="n">target_columns</span><span class="p">,</span>
            <span class="n">config</span><span class="o">.</span><span class="n">target_column_types</span><span class="p">,</span>
            <span class="n">config</span><span class="o">.</span><span class="n">sample_from_distribution_columns</span><span class="p">,</span>
            <span class="n">config</span><span class="o">.</span><span class="n">infer_with_dropout</span><span class="p">,</span>
            <span class="n">config</span><span class="o">.</span><span class="n">inference_batch_size</span><span class="p">,</span>
            <span class="n">config</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="n">args_config</span><span class="o">=</span><span class="n">args_config</span><span class="p">,</span>
            <span class="n">training_config_path</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">training_config_path</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">column_types</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">col</span><span class="p">:</span> <span class="n">PANDAS_TO_TORCH_TYPES</span><span class="p">[</span><span class="n">config</span><span class="o">.</span><span class="n">column_types</span><span class="p">[</span><span class="n">col</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">column_types</span>
        <span class="p">}</span>

        <span class="n">model_id</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">model_path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">inferer</span><span class="o">.</span><span class="n">inference_model_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
        <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Inferring for </span><span class="si">{</span><span class="n">model_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;generative&quot;</span><span class="p">:</span>
            <span class="n">infer_generative</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">inferer</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">column_types</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;embedding&quot;</span><span class="p">:</span>
            <span class="n">infer_embedding</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">inferer</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">column_types</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--- Inference Complete ---&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="infer_embedding">
<a class="viewcode-back" href="../../api.html#sequifier.infer.infer_embedding">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">infer_embedding</span><span class="p">(</span>
    <span class="n">config</span><span class="p">:</span> <span class="s2">&quot;InfererModel&quot;</span><span class="p">,</span>
    <span class="n">inferer</span><span class="p">:</span> <span class="s2">&quot;Inferer&quot;</span><span class="p">,</span>
    <span class="n">model_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">dataset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Any</span><span class="p">]],</span>
    <span class="n">column_types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Performs inference with an embedding model and saves the results.</span>

<span class="sd">    This function iterates through the provided dataset (which can be a list</span>
<span class="sd">    of DataFrames or an iterator of tensors). For each data chunk, it</span>
<span class="sd">    calls the appropriate function (`get_embeddings` or `get_embeddings_pt`)</span>
<span class="sd">    to generate embeddings. It then formats these embeddings into a</span>
<span class="sd">    Polars DataFrame, associating them with their `sequenceId` and</span>
<span class="sd">    `subsequenceId`, and writes the resulting DataFrame to the configured output path.</span>

<span class="sd">    Args:</span>
<span class="sd">        config: The `InfererModel` configuration object.</span>
<span class="sd">        inferer: The initialized `Inferer` instance.</span>
<span class="sd">        model_id: A string identifier for the model, used for naming</span>
<span class="sd">            output files.</span>
<span class="sd">        dataset: A list containing a Polars DataFrame (for parquet/csv) or</span>
<span class="sd">            an iterator of loaded PyTorch data (for .pt files).</span>
<span class="sd">        column_types: A dictionary mapping column names to their</span>
<span class="sd">            `torch.dtype`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">data_id</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
        <span class="c1"># Step 1: Adapt Data Subsetting (now works on Polars DF)</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">read_format</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;parquet&quot;</span><span class="p">,</span> <span class="s2">&quot;csv&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">selected_columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">subset_to_selected_columns</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">selected_columns</span><span class="p">)</span>
            <span class="n">n_input_cols</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span><span class="s2">&quot;inputCol&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">n_unique</span><span class="p">()</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">eager</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_input_cols</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">embeddings</span> <span class="o">=</span> <span class="n">get_embeddings</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">inferer</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">column_types</span><span class="p">)</span>
            <span class="n">sequence_ids_for_preds</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span><span class="s2">&quot;sequenceId&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">subsequence_ids_for_preds</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;subsequenceId&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">config</span><span class="o">.</span><span class="n">read_format</span> <span class="o">==</span> <span class="s2">&quot;pt&quot;</span><span class="p">:</span>
            <span class="n">sequences_dict</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sequence_ids_tensor</span><span class="p">,</span> <span class="n">subsequence_ids_tensor</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">embeddings</span> <span class="o">=</span> <span class="n">get_embeddings_pt</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">inferer</span><span class="p">,</span> <span class="n">sequences_dict</span><span class="p">)</span>
            <span class="n">sequence_ids_for_preds</span> <span class="o">=</span> <span class="n">sequence_ids_tensor</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="n">subsequence_ids_for_preds</span> <span class="o">=</span> <span class="n">subsequence_ids_tensor</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;impossible&quot;</span><span class="p">)</span>

        <span class="n">embeddings</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;sequenceId&quot;</span><span class="p">:</span> <span class="n">sequence_ids_for_preds</span><span class="p">,</span>
                <span class="s2">&quot;subsequenceId&quot;</span><span class="p">:</span> <span class="n">subsequence_ids_for_preds</span><span class="p">,</span>
                <span class="o">**</span><span class="nb">dict</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span>
                        <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">embeddings</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>
                        <span class="p">[</span><span class="n">embeddings</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">embeddings</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>
                    <span class="p">)</span>
                <span class="p">),</span>
            <span class="p">}</span>
        <span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">project_path</span><span class="p">,</span> <span class="s2">&quot;outputs&quot;</span><span class="p">,</span> <span class="s2">&quot;embeddings&quot;</span><span class="p">),</span>
            <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">read_format</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;csv&quot;</span><span class="p">,</span> <span class="s2">&quot;parquet&quot;</span><span class="p">]:</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_id</span><span class="si">}</span><span class="s2">-embeddings.</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">write_format</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_id</span><span class="si">}</span><span class="s2">-embeddings&quot;</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">dirname</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_id</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">data_id</span><span class="si">}</span><span class="s2">-embeddings.</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">write_format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">dir_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">config</span><span class="o">.</span><span class="n">project_path</span><span class="p">,</span> <span class="s2">&quot;outputs&quot;</span><span class="p">,</span> <span class="s2">&quot;embeddings&quot;</span><span class="p">,</span> <span class="n">dirname</span>
            <span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">embeddings_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">config</span><span class="o">.</span><span class="n">project_path</span><span class="p">,</span> <span class="s2">&quot;outputs&quot;</span><span class="p">,</span> <span class="s2">&quot;embeddings&quot;</span><span class="p">,</span> <span class="n">file_name</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Writing predictions to &#39;</span><span class="si">{</span><span class="n">embeddings_path</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span>
            <span class="n">embeddings</span><span class="p">,</span>
            <span class="n">embeddings_path</span><span class="p">,</span>
            <span class="n">config</span><span class="o">.</span><span class="n">write_format</span><span class="p">,</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="infer_generative">
<a class="viewcode-back" href="../../api.html#sequifier.infer.infer_generative">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">infer_generative</span><span class="p">(</span>
    <span class="n">config</span><span class="p">:</span> <span class="s2">&quot;InfererModel&quot;</span><span class="p">,</span>
    <span class="n">inferer</span><span class="p">:</span> <span class="s2">&quot;Inferer&quot;</span><span class="p">,</span>
    <span class="n">model_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">dataset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Any</span><span class="p">]],</span>
    <span class="n">column_types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Performs inference with a generative model and saves the results.</span>

<span class="sd">    This function manages the generative inference workflow:</span>
<span class="sd">    1. Iterates through the dataset (chunks).</span>
<span class="sd">    2. Handles data preparation, including expanding data for autoregression</span>
<span class="sd">       if configured (`expand_data_by_autoregression`). It also calculates</span>
<span class="sd">       the corresponding `itemPosition` for each prediction.</span>
<span class="sd">    3. Calls the correct function to get probabilities and predictions</span>
<span class="sd">       based on data format and autoregression settings (e.g.,</span>
<span class="sd">       `get_probs_preds_autoregression`, `get_probs_preds_pt`).</span>
<span class="sd">    4. Post-processes predictions:</span>
<span class="sd">       - Maps integer predictions back to original IDs if `map_to_id` is True.</span>
<span class="sd">       - Inverts normalization for real-valued target columns.</span>
<span class="sd">    5. Saves probabilities to disk (if `config.output_probabilities` is True).</span>
<span class="sd">    6. Saves the final predictions to disk, formatted as a Polars DataFrame</span>
<span class="sd">       with `sequenceId`, `itemPosition`, and target columns.</span>

<span class="sd">    Args:</span>
<span class="sd">        config: The `InfererModel` configuration object.</span>
<span class="sd">        inferer: The initialized `Inferer` instance.</span>
<span class="sd">        model_id: A string identifier for the model, used for naming</span>
<span class="sd">            output files.</span>
<span class="sd">        dataset: A list containing a Polars DataFrame (for parquet/csv) or</span>
<span class="sd">            an iterator of loaded PyTorch data (for .pt files).</span>
<span class="sd">        column_types: A dictionary mapping column names to their</span>
<span class="sd">            `torch.dtype`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">data_id</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
        <span class="c1"># Step 1: Adapt Data Subsetting (now works on Polars DF)</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">read_format</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;parquet&quot;</span><span class="p">,</span> <span class="s2">&quot;csv&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">selected_columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">subset_to_selected_columns</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">selected_columns</span><span class="p">)</span>
            <span class="n">n_input_cols</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span><span class="s2">&quot;inputCol&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">n_unique</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">config</span><span class="o">.</span><span class="n">autoregression</span><span class="p">:</span>
                <span class="c1"># For the non-autoregressive case, the old logic is still needed here</span>
                <span class="c1"># Apply the mask to the sequenceId column</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">eager</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_input_cols</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="n">sequence_ids_for_preds</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span><span class="s2">&quot;sequenceId&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="n">item_positions_for_preds</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span><span class="s2">&quot;startItemPosition&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                    <span class="o">+</span> <span class="n">config</span><span class="o">.</span><span class="n">seq_length</span>
                <span class="p">)</span>
                <span class="n">probs</span><span class="p">,</span> <span class="n">preds</span> <span class="o">=</span> <span class="n">get_probs_preds</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">inferer</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">column_types</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">autoregression_extra_steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">expand_data_by_autoregression</span><span class="p">(</span>
                        <span class="n">data</span><span class="p">,</span>
                        <span class="n">config</span><span class="o">.</span><span class="n">autoregression_extra_steps</span><span class="p">,</span>
                        <span class="n">config</span><span class="o">.</span><span class="n">seq_length</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">eager</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_input_cols</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="n">item_positions_for_preds</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span><span class="s2">&quot;startItemPosition&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                    <span class="o">+</span> <span class="n">config</span><span class="o">.</span><span class="n">seq_length</span>
                <span class="p">)</span>
                <span class="c1"># Unpack the new third return value</span>
                <span class="n">probs</span><span class="p">,</span> <span class="n">preds</span><span class="p">,</span> <span class="n">sequence_ids_for_preds</span> <span class="o">=</span> <span class="n">get_probs_preds_autoregression</span><span class="p">(</span>
                    <span class="n">config</span><span class="p">,</span> <span class="n">inferer</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">column_types</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">seq_length</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">config</span><span class="o">.</span><span class="n">read_format</span> <span class="o">==</span> <span class="s2">&quot;pt&quot;</span><span class="p">:</span>
            <span class="n">sequences_dict</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sequence_ids_tensor</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">start_positions_tensor</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">extra_steps</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">0</span>
                <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">autoregression_extra_steps</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="n">config</span><span class="o">.</span><span class="n">autoregression_extra_steps</span>
            <span class="p">)</span>
            <span class="n">probs</span><span class="p">,</span> <span class="n">preds</span> <span class="o">=</span> <span class="n">get_probs_preds_pt</span><span class="p">(</span>
                <span class="n">config</span><span class="p">,</span> <span class="n">inferer</span><span class="p">,</span> <span class="n">sequences_dict</span><span class="p">,</span> <span class="n">extra_steps</span>
            <span class="p">)</span>
            <span class="n">sequence_ids_for_preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="n">sequence_ids_tensor</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">extra_steps</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">item_position_boundaries</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="n">start_positions_tensor</span> <span class="o">+</span> <span class="n">config</span><span class="o">.</span><span class="n">seq_length</span><span class="p">),</span>
                <span class="nb">list</span><span class="p">(</span><span class="n">start_positions_tensor</span> <span class="o">+</span> <span class="n">config</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">+</span> <span class="n">extra_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">item_positions_for_preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">item_position_boundaries</span><span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;impossible&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inferer</span><span class="o">.</span><span class="n">map_to_id</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">target_column</span><span class="p">,</span> <span class="n">predictions</span> <span class="ow">in</span> <span class="n">preds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">target_column</span> <span class="ow">in</span> <span class="n">inferer</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
                    <span class="n">preds</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">inferer</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">target_column</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">predictions</span><span class="p">]</span>
                    <span class="p">)</span>

        <span class="k">for</span> <span class="n">target_column</span><span class="p">,</span> <span class="n">predictions</span> <span class="ow">in</span> <span class="n">preds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">inferer</span><span class="o">.</span><span class="n">target_column_types</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;real&quot;</span><span class="p">:</span>
                <span class="n">preds</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">inferer</span><span class="o">.</span><span class="n">invert_normalization</span><span class="p">(</span>
                    <span class="n">predictions</span><span class="p">,</span> <span class="n">target_column</span>
                <span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">project_path</span><span class="p">,</span> <span class="s2">&quot;outputs&quot;</span><span class="p">,</span> <span class="s2">&quot;predictions&quot;</span><span class="p">),</span>
            <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">output_probabilities</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">probs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">project_path</span><span class="p">,</span> <span class="s2">&quot;outputs&quot;</span><span class="p">,</span> <span class="s2">&quot;probabilities&quot;</span><span class="p">),</span>
                <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">target_column</span> <span class="ow">in</span> <span class="n">inferer</span><span class="o">.</span><span class="n">target_columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">read_format</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;csv&quot;</span><span class="p">,</span> <span class="s2">&quot;parquet&quot;</span><span class="p">]:</span>
                    <span class="n">file_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_id</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">target_column</span><span class="si">}</span><span class="s2">-probabilities.</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">write_format</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dirname</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_id</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">target_column</span><span class="si">}</span><span class="s2">-probabilities&quot;</span>
                    <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">dirname</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_id</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">data_id</span><span class="si">}</span><span class="s2">-probabilities.</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">write_format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="n">dir_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">config</span><span class="o">.</span><span class="n">project_path</span><span class="p">,</span> <span class="s2">&quot;outputs&quot;</span><span class="p">,</span> <span class="s2">&quot;probabilities&quot;</span><span class="p">,</span> <span class="n">dirname</span>
                    <span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">inferer</span><span class="o">.</span><span class="n">target_column_types</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;categorical&quot;</span><span class="p">:</span>
                    <span class="n">probabilities_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">config</span><span class="o">.</span><span class="n">project_path</span><span class="p">,</span> <span class="s2">&quot;outputs&quot;</span><span class="p">,</span> <span class="s2">&quot;probabilities&quot;</span><span class="p">,</span> <span class="n">file_name</span>
                    <span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Writing probabilities to &#39;</span><span class="si">{</span><span class="n">probabilities_path</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                    <span class="c1"># Step 5: Finalize Output and I/O (write_data now handles Polars DF)</span>
                    <span class="n">write_data</span><span class="p">(</span>
                        <span class="n">pl</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                            <span class="n">probs</span><span class="p">[</span><span class="n">target_column</span><span class="p">],</span>
                            <span class="n">schema</span><span class="o">=</span><span class="p">[</span>
                                <span class="n">inferer</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">target_column</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="p">],</span>
                        <span class="p">),</span>
                        <span class="n">probabilities_path</span><span class="p">,</span>
                        <span class="n">config</span><span class="o">.</span><span class="n">write_format</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="n">n_input_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">selected_columns</span><span class="p">)</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;sequenceId&quot;</span><span class="p">:</span> <span class="n">sequence_ids_for_preds</span><span class="p">,</span>
                <span class="s2">&quot;itemPosition&quot;</span><span class="p">:</span> <span class="n">item_positions_for_preds</span><span class="p">,</span>
                <span class="o">**</span><span class="p">{</span>
                    <span class="n">target_column</span><span class="p">:</span> <span class="n">preds</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">target_column</span> <span class="ow">in</span> <span class="n">inferer</span><span class="o">.</span><span class="n">target_columns</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">read_format</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;csv&quot;</span><span class="p">,</span> <span class="s2">&quot;parquet&quot;</span><span class="p">]:</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_id</span><span class="si">}</span><span class="s2">-predictions.</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">write_format</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_id</span><span class="si">}</span><span class="s2">-predictions&quot;</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">dirname</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_id</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">data_id</span><span class="si">}</span><span class="s2">-predictions.</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">write_format</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">dir_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">config</span><span class="o">.</span><span class="n">project_path</span><span class="p">,</span> <span class="s2">&quot;outputs&quot;</span><span class="p">,</span> <span class="s2">&quot;predictions&quot;</span><span class="p">,</span> <span class="n">dirname</span>
            <span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">predictions_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">config</span><span class="o">.</span><span class="n">project_path</span><span class="p">,</span> <span class="s2">&quot;outputs&quot;</span><span class="p">,</span> <span class="s2">&quot;predictions&quot;</span><span class="p">,</span> <span class="n">file_name</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Writing predictions to &#39;</span><span class="si">{</span><span class="n">predictions_path</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span>
            <span class="n">predictions</span><span class="p">,</span>
            <span class="n">predictions_path</span><span class="p">,</span>
            <span class="n">config</span><span class="o">.</span><span class="n">write_format</span><span class="p">,</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="expand_data_by_autoregression">
<a class="viewcode-back" href="../../api.html#sequifier.infer.expand_data_by_autoregression">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">expand_data_by_autoregression</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">autoregression_extra_steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">seq_length</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Expands a Polars DataFrame for autoregressive inference.</span>

<span class="sd">    This function takes a DataFrame of sequences and adds</span>
<span class="sd">    `autoregression_extra_steps` new rows for each sequence. These new</span>
<span class="sd">    rows represent future time steps to be predicted.</span>

<span class="sd">    For each new step, it:</span>
<span class="sd">    1. Copies the last known observation for a sequence.</span>
<span class="sd">    2. Increments the `subsequenceId`.</span>
<span class="sd">    3. Shifts the historical data columns (e.g., &#39;1&#39;, &#39;2&#39;, ..., &#39;50&#39;) one</span>
<span class="sd">       position &quot;older&quot; (e.g., old &#39;1&#39; becomes new &#39;2&#39;, old &#39;49&#39; becomes</span>
<span class="sd">       new &#39;50&#39;).</span>
<span class="sd">    4. Fills the &quot;newest&quot; columns (e.g., new &#39;1&#39; for the first extra</span>
<span class="sd">       step) with `np.inf` as a placeholder for the prediction.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: The input Polars DataFrame, sorted by `sequenceId` and</span>
<span class="sd">            `subsequenceId`.</span>
<span class="sd">        autoregression_extra_steps: The number of future time steps to add</span>
<span class="sd">            to each sequence.</span>
<span class="sd">        seq_length: The sequence length, used to identify the historical</span>
<span class="sd">            data columns (named &#39;1&#39; through `seq_length`).</span>

<span class="sd">    Returns:</span>
<span class="sd">        A new Polars DataFrame containing all original rows plus the</span>
<span class="sd">        newly generated future rows with placeholders.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure data is sorted for window functions</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s2">&quot;sequenceId&quot;</span><span class="p">,</span> <span class="s2">&quot;subsequenceId&quot;</span><span class="p">)</span>

    <span class="c1"># Identify the last observation for each sequence</span>
    <span class="n">last_obs_lazy</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">lazy</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;subsequenceId&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;subsequenceId&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="s2">&quot;sequenceId&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Generate future rows lazily</span>
    <span class="n">future_frames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">data_cols</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">seq_length</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">autoregression_extra_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">future_df_lazy</span> <span class="o">=</span> <span class="n">last_obs_lazy</span><span class="o">.</span><span class="n">with_columns</span><span class="p">(</span>
            <span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;subsequenceId&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;subsequenceId&quot;</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">with_columns</span><span class="p">(</span>
            <span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;startItemPosition&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;startItemPosition&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Correctly shift columns to make space for future predictions</span>
        <span class="c1"># Newest value (col &#39;1&#39;) becomes a placeholder, old &#39;1&#39; becomes new &#39;2&#39;, etc.</span>
        <span class="n">update_exprs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_cols</span><span class="p">)):</span>  <span class="c1"># e.g., i from 0 to 49 for seq_length=50</span>
            <span class="n">col_to_update</span> <span class="o">=</span> <span class="n">data_cols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># Updates &#39;50&#39;, &#39;49&#39;, ..., &#39;1&#39;</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_cols</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">:</span>
                <span class="c1"># Shift historical data one step further into the past</span>
                <span class="c1"># e.g., new &#39;50&#39; gets old &#39;49&#39;, new &#39;2&#39; gets old &#39;1&#39;</span>
                <span class="n">source_col_name</span> <span class="o">=</span> <span class="n">data_cols</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">offset</span><span class="p">]</span>
                <span class="n">update_exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">source_col_name</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">col_to_update</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># These are the newest &#39;offset&#39; columns, which are unknown.</span>
                <span class="c1"># Fill with infinity as a placeholder for the prediction.</span>
                <span class="c1"># e.g., for offset=1, new col &#39;1&#39; becomes inf.</span>
                <span class="n">update_exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pl</span><span class="o">.</span><span class="n">Float64</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">col_to_update</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="n">future_df_lazy</span> <span class="o">=</span> <span class="n">future_df_lazy</span><span class="o">.</span><span class="n">with_columns</span><span class="p">(</span><span class="n">update_exprs</span><span class="p">)</span>
        <span class="n">future_frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">future_df_lazy</span><span class="p">)</span>

    <span class="c1"># Concatenate original data with all future frames</span>
    <span class="n">final_lazy</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">lazy</span><span class="p">()]</span> <span class="o">+</span> <span class="n">future_frames</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">final_lazy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s2">&quot;sequenceId&quot;</span><span class="p">,</span> <span class="s2">&quot;subsequenceId&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>



<div class="viewcode-block" id="get_embeddings_pt">
<a class="viewcode-back" href="../../api.html#sequifier.infer.get_embeddings_pt">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_embeddings_pt</span><span class="p">(</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">inferer</span><span class="p">:</span> <span class="s2">&quot;Inferer&quot;</span><span class="p">,</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates embeddings from a batch of PyTorch tensor data.</span>

<span class="sd">    This function serves as a wrapper for `Inferer.infer_embedding` when</span>
<span class="sd">    the input data is already in PyTorch tensor format (from loading `.pt`</span>
<span class="sd">    files which contain sequences, targets, sequence_ids, subsequence_ids,</span>
<span class="sd">    and start_positions). It converts the tensor dictionary to a NumPy array</span>
<span class="sd">    dictionary before passing it to the inferer.</span>

<span class="sd">    Args:</span>
<span class="sd">        config: The `InfererModel` configuration object (unused, but</span>
<span class="sd">            kept for consistent function signature).</span>
<span class="sd">        inferer: The initialized `Inferer` instance.</span>
<span class="sd">        data: A dictionary mapping column/feature names to `torch.Tensor`s</span>
<span class="sd">              (the sequences part loaded from the .pt file).</span>

<span class="sd">    Returns:</span>
<span class="sd">        A NumPy array containing the computed embeddings for the batch.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">embeddings</span> <span class="o">=</span> <span class="n">inferer</span><span class="o">.</span><span class="n">infer_embedding</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">embeddings</span></div>



<div class="viewcode-block" id="get_probs_preds_pt">
<a class="viewcode-back" href="../../api.html#sequifier.infer.get_probs_preds_pt">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_probs_preds_pt</span><span class="p">(</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">inferer</span><span class="p">:</span> <span class="s2">&quot;Inferer&quot;</span><span class="p">,</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
    <span class="n">extra_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates predictions from PyTorch tensor data, supporting autoregression.</span>

<span class="sd">    This function performs generative inference on a batch of PyTorch tensor</span>
<span class="sd">    data loaded from `.pt` files (which contain sequences, targets,</span>
<span class="sd">    sequence_ids, subsequence_ids, and start_positions). It implements an</span>
<span class="sd">    autoregressive loop:</span>
<span class="sd">    1. Runs inference on the initial data `X` (sequences).</span>
<span class="sd">    2. For each subsequent step (`i` in `extra_steps`):</span>
<span class="sd">       a. Creates the next input `X_next` by shifting the previous input</span>
<span class="sd">          `X` and appending the prediction from the last step.</span>
<span class="sd">       b. Runs inference on `X_next`.</span>
<span class="sd">    3. Collects and reshapes all predictions and probabilities from all</span>
<span class="sd">       steps into a single flat batch, ordered by original sample index, then by step.</span>

<span class="sd">    Args:</span>
<span class="sd">        config: The `InfererModel` configuration object, used to check</span>
<span class="sd">            `output_probabilities` and `selected_columns`.</span>
<span class="sd">        inferer: The initialized `Inferer` instance.</span>
<span class="sd">        data: A dictionary mapping column/feature names to `torch.Tensor`s</span>
<span class="sd">              (the sequences part loaded from the .pt file).</span>
<span class="sd">        extra_steps: The number of additional autoregressive steps to</span>
<span class="sd">            perform. A value of 0 means simple, non-autoregressive</span>
<span class="sd">            inference.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple `(probs, preds)`:</span>
<span class="sd">            - `probs`: A dictionary mapping target columns to NumPy arrays</span>
<span class="sd">              of probabilities, ordered by sample index then step,</span>
<span class="sd">              or `None` if `config.output_probabilities` is False.</span>
<span class="sd">            - `preds`: A dictionary mapping target columns to NumPy arrays</span>
<span class="sd">              of final predictions, ordered by sample index then step.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">target_cols</span> <span class="o">=</span> <span class="n">inferer</span><span class="o">.</span><span class="n">target_columns</span>

    <span class="c1"># 2. Initialize input and containers for storing results from all steps</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">tensor</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">selected_columns</span>
    <span class="p">}</span>
    <span class="n">all_probs_list</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">target_cols</span><span class="p">}</span>
    <span class="n">all_preds_list</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">target_cols</span><span class="p">}</span>

    <span class="c1"># 3. Autoregressive loop</span>
    <span class="c1"># The loop runs `extra_steps + 1` times to get the initial prediction plus all extra steps.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">extra_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">output_probabilities</span><span class="p">:</span>
            <span class="n">probs_for_step</span> <span class="o">=</span> <span class="n">inferer</span><span class="o">.</span><span class="n">infer_generative</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">return_probs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">preds_for_step</span> <span class="o">=</span> <span class="n">inferer</span><span class="o">.</span><span class="n">infer_generative</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">probs_for_step</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">target_cols</span><span class="p">:</span>
                <span class="n">all_probs_list</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">probs_for_step</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">preds_for_step</span> <span class="o">=</span> <span class="n">inferer</span><span class="o">.</span><span class="n">infer_generative</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">return_probs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">target_cols</span><span class="p">:</span>
            <span class="n">all_preds_list</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">preds_for_step</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">extra_steps</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">X_next</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">shifted_input</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">col</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">:]</span>

            <span class="n">new_value</span> <span class="o">=</span> <span class="n">preds_for_step</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">shifted_input</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">X_next</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">shifted_input</span><span class="p">,</span> <span class="n">new_value</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">X_next</span>

    <span class="n">final_preds</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">col</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">preds_list</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">preds_list</span> <span class="ow">in</span> <span class="n">all_preds_list</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">output_probabilities</span><span class="p">:</span>
        <span class="n">final_probs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">col</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">probs_list</span><span class="p">)</span>
            <span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">probs_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">probs_list</span> <span class="ow">in</span> <span class="n">all_probs_list</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final_probs</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">final_probs</span><span class="p">,</span> <span class="n">final_preds</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_embeddings">
<a class="viewcode-back" href="../../api.html#sequifier.infer.get_embeddings">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_embeddings</span><span class="p">(</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">inferer</span><span class="p">:</span> <span class="s2">&quot;Inferer&quot;</span><span class="p">,</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates embeddings from a Polars DataFrame.</span>

<span class="sd">    This function converts a Polars DataFrame into the NumPy array dictionary</span>
<span class="sd">    format expected by the `Inferer`. It uses `numpy_to_pytorch` for the</span>
<span class="sd">    main conversion, then transforms the tensors to NumPy arrays before</span>
<span class="sd">    passing them to `inferer.infer_embedding`.</span>

<span class="sd">    Args:</span>
<span class="sd">        config: The `InfererModel` configuration object.</span>
<span class="sd">        inferer: The initialized `Inferer` instance.</span>
<span class="sd">        data: The input Polars DataFrame chunk.</span>
<span class="sd">        column_types: A dictionary mapping column names to `torch.dtype`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A NumPy array containing the computed embeddings for the batch.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_columns</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">selected_columns</span> <span class="o">+</span> <span class="n">config</span><span class="o">.</span><span class="n">target_columns</span><span class="p">)))</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">numpy_to_pytorch</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">column_types</span><span class="p">,</span> <span class="n">all_columns</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">seq_length</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="n">X_col</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">X_col</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">del</span> <span class="n">data</span>

    <span class="n">embeddings</span> <span class="o">=</span> <span class="n">inferer</span><span class="o">.</span><span class="n">infer_embedding</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">embeddings</span></div>



<div class="viewcode-block" id="get_probs_preds">
<a class="viewcode-back" href="../../api.html#sequifier.infer.get_probs_preds">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_probs_preds</span><span class="p">(</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">inferer</span><span class="p">:</span> <span class="s2">&quot;Inferer&quot;</span><span class="p">,</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates predictions from a Polars DataFrame (non-autoregressive).</span>

<span class="sd">    This function converts a Polars DataFrame into the NumPy array dictionary</span>
<span class="sd">    format expected by the `Inferer`. It&#39;s used for standard,</span>
<span class="sd">    non-autoregressive generative inference.</span>
<span class="sd">    It calls `inferer.infer_generative` once and returns the</span>
<span class="sd">    probabilities (if requested) and predictions.</span>

<span class="sd">    Args:</span>
<span class="sd">        config: The `InfererModel` configuration object.</span>
<span class="sd">        inferer: The initialized `Inferer` instance.</span>
<span class="sd">        data: The input Polars DataFrame chunk.</span>
<span class="sd">        column_types: A dictionary mapping column names to `torch.dtype`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple `(probs, preds)`:</span>
<span class="sd">            - `probs`: A dictionary mapping target columns to NumPy arrays</span>
<span class="sd">              of probabilities, or `None` if `config.output_probabilities`</span>
<span class="sd">              is False.</span>
<span class="sd">            - `preds`: A dictionary mapping target columns to NumPy arrays</span>
<span class="sd">              of final predictions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_columns</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">selected_columns</span> <span class="o">+</span> <span class="n">config</span><span class="o">.</span><span class="n">target_columns</span><span class="p">)))</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">numpy_to_pytorch</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">column_types</span><span class="p">,</span> <span class="n">all_columns</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">seq_length</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="n">X_col</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">X_col</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">del</span> <span class="n">data</span>

    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">output_probabilities</span><span class="p">:</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">inferer</span><span class="o">.</span><span class="n">infer_generative</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">return_probs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="n">inferer</span><span class="o">.</span><span class="n">infer_generative</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="n">inferer</span><span class="o">.</span><span class="n">infer_generative</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">preds</span><span class="p">)</span></div>



<div class="viewcode-block" id="fill_in_predictions_pl">
<a class="viewcode-back" href="../../api.html#sequifier.infer.fill_in_predictions_pl">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fill_in_predictions_pl</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">preds</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">current_subsequence_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sequence_ids_present</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
    <span class="n">seq_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pl</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fills in predictions into the main Polars DataFrame using a robust,</span>
<span class="sd">    join-based approach that preserves the original DataFrame&#39;s structure.</span>

<span class="sd">    This function broadcasts predictions to all relevant future rows via a join,</span>
<span class="sd">    then uses conditional expressions to update only the specific placeholder</span>
<span class="sd">    cells (`np.inf`) that correspond to the correct future time step.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: The main DataFrame containing all sequences.</span>
<span class="sd">        preds: A dictionary of new predictions, mapping target column names to NumPy arrays.</span>
<span class="sd">        current_subsequence_id: The adjusted subsequence ID at which predictions were made.</span>
<span class="sd">        sequence_ids_present: A Polars Series of the sequence IDs in the current batch.</span>
<span class="sd">        seq_length: The length of the sequence.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An updated Polars DataFrame with the same dimensions as the input, with</span>
<span class="sd">        future placeholder values filled in.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span> <span class="ow">or</span> <span class="n">sequence_ids_present</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="c1"># 1. Create a &quot;long&quot; format DataFrame of the new predictions.</span>
    <span class="c1"># This table has columns [sequenceId, inputCol, prediction].</span>
    <span class="n">pred_dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">input_col</span><span class="p">,</span> <span class="n">pred_values</span> <span class="ow">in</span> <span class="n">preds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">pred_values</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pred_dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">pl</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;sequenceId&quot;</span><span class="p">:</span> <span class="n">sequence_ids_present</span><span class="p">,</span>
                        <span class="s2">&quot;inputCol&quot;</span><span class="p">:</span> <span class="n">input_col</span><span class="p">,</span>
                        <span class="s2">&quot;prediction&quot;</span><span class="p">:</span> <span class="n">pred_values</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="c1"># If there are no valid predictions to process, return the original data.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pred_dfs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="n">preds_df</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">pred_dfs</span><span class="p">)</span>

    <span class="c1"># 2. Left-join the predictions onto the main DataFrame.</span>
    <span class="c1"># This adds a &#39;prediction&#39; column. Rows that don&#39;t match the join keys</span>
    <span class="c1"># (e.g., non-target columns) will have a null value for &#39;prediction&#39;.</span>
    <span class="c1"># A left join guarantees that no rows from the original `data` are dropped.</span>
    <span class="n">data_with_preds</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">preds_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sequenceId&quot;</span><span class="p">,</span> <span class="s2">&quot;inputCol&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="c1"># 3. Build a list of conditional update expressions for each future time step.</span>
    <span class="n">update_expressions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">seq_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">col_to_update</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

        <span class="c1"># Skip if the column to update doesn&#39;t exist in the DataFrame.</span>
        <span class="k">if</span> <span class="n">col_to_update</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># The core logic: A prediction made at `current_subsequence_id` for a given</span>
        <span class="c1"># `offset` should fill the placeholder in column `str(offset)` at the row</span>
        <span class="c1"># where `subsequenceIdAdjusted` is `current_subsequence_id + offset`.</span>
        <span class="n">update_expr</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pl</span><span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="c1"># Condition 1: Is this the correct future row to update?</span>
                <span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;subsequenceIdAdjusted&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">current_subsequence_id</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
                <span class="c1"># Condition 2: Does the cell contain a placeholder that needs updating?</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">col_to_update</span><span class="p">)</span><span class="o">.</span><span class="n">is_infinite</span><span class="p">())</span>
                <span class="c1"># Condition 3: Is there a valid prediction available from the join?</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;prediction&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_not_null</span><span class="p">())</span>
            <span class="p">)</span>
            <span class="c1"># If all conditions are met, use the new prediction value.</span>
            <span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;prediction&quot;</span><span class="p">))</span>
            <span class="c1"># IMPORTANT: Otherwise, keep the column&#39;s existing value. This is crucial</span>
            <span class="c1"># for preserving the integrity of the DataFrame.</span>
            <span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">col_to_update</span><span class="p">))</span>
            <span class="c1"># Overwrite the original column with the updated values.</span>
            <span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">col_to_update</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">update_expressions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">update_expr</span><span class="p">)</span>

    <span class="c1"># 4. Apply all expressions at once and remove the temporary &#39;prediction&#39; column.</span>
    <span class="c1"># The `with_columns` operation does not change the number of rows.</span>
    <span class="k">if</span> <span class="n">update_expressions</span><span class="p">:</span>
        <span class="n">updated_data</span> <span class="o">=</span> <span class="n">data_with_preds</span><span class="o">.</span><span class="n">with_columns</span><span class="p">(</span><span class="n">update_expressions</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
            <span class="s2">&quot;prediction&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If no updates were needed, just drop the temporary join column.</span>
        <span class="n">updated_data</span> <span class="o">=</span> <span class="n">data_with_preds</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;prediction&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">updated_data</span></div>



<div class="viewcode-block" id="fill_number">
<a class="viewcode-back" href="../../api.html#sequifier.infer.fill_number">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fill_number</span><span class="p">(</span><span class="n">number</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">max_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pads a number with leading zeros to a specified string length.</span>

<span class="sd">    Used for creating sortable string keys (e.g., &quot;001-001&quot;, &quot;001-002&quot;).</span>

<span class="sd">    Args:</span>
<span class="sd">        number: The integer or float to format.</span>
<span class="sd">        max_length: The total desired length of the output string.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A string representation of the number, padded with leading zeros.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">number_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;0&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">max_length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">number_str</span><span class="p">))</span><span class="si">}{</span><span class="n">number_str</span><span class="si">}</span><span class="s2">&quot;</span></div>



<div class="viewcode-block" id="verify_variable_order">
<a class="viewcode-back" href="../../api.html#sequifier.infer.verify_variable_order">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">verify_variable_order</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verifies that the DataFrame is correctly sorted for autoregression.</span>

<span class="sd">    Checks two conditions:</span>
<span class="sd">    1. `sequenceId` is globally sorted in ascending order.</span>
<span class="sd">    2. `subsequenceId` is sorted in ascending order *within* each</span>
<span class="sd">       `sequenceId` group.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: The Polars DataFrame to check.</span>

<span class="sd">    Raises:</span>
<span class="sd">        AssertionError: If `sequenceId` is not globally sorted or if</span>
<span class="sd">            `subsequenceId` is not sorted within `sequenceId` groups.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if the entire &#39;sequenceId&#39; column is sorted. This is a global property.</span>
    <span class="n">is_globally_sorted</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
        <span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;sequenceId&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span><span class="o">.</span><span class="n">fill_null</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">is_globally_sorted</span>
    <span class="p">),</span> <span class="s2">&quot;sequenceId must be in ascending order for autoregression&quot;</span>

    <span class="c1"># Check if &#39;subsequenceId&#39; is sorted within each &#39;sequenceId&#39; group.</span>
    <span class="c1"># This results in a boolean Series, on which we can call .all() directly.</span>
    <span class="n">is_group_sorted</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">data</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;subsequenceId&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span><span class="o">.</span><span class="n">fill_null</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">.</span><span class="n">all</span><span class="p">()</span>
            <span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="s2">&quot;sequenceId&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;is_sorted&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">get_column</span><span class="p">(</span><span class="s2">&quot;is_sorted&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="k">assert</span> <span class="n">is_group_sorted</span><span class="p">,</span> <span class="s2">&quot;subsequenceId must be in ascending order within each sequenceId for autoregression&quot;</span></div>



<div class="viewcode-block" id="format_delta">
<a class="viewcode-back" href="../../api.html#sequifier.infer.format_delta">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">format_delta</span><span class="p">(</span><span class="n">time_delta</span><span class="p">:</span> <span class="n">timedelta</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Formats a `timedelta` object into a human-readable string (seconds).</span>

<span class="sd">    Args:</span>
<span class="sd">        time_delta: The `timedelta` object to format.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A string representing the total seconds with 3 decimal places.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">seconds</span> <span class="o">=</span> <span class="n">time_delta</span><span class="o">.</span><span class="n">seconds</span>
    <span class="n">microseconds</span> <span class="o">=</span> <span class="n">time_delta</span><span class="o">.</span><span class="n">microseconds</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="n">seconds</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">microseconds</span><span class="o">/</span><span class="mf">1e6</span><span class="p">))</span><span class="si">:</span><span class="s2">.3</span><span class="si">}</span><span class="s2">&quot;</span></div>



<div class="viewcode-block" id="get_probs_preds_autoregression">
<a class="viewcode-back" href="../../api.html#sequifier.infer.get_probs_preds_autoregression">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_probs_preds_autoregression</span><span class="p">(</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">inferer</span><span class="p">:</span> <span class="s2">&quot;Inferer&quot;</span><span class="p">,</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">pl</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span>
    <span class="n">seq_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Performs autoregressive inference using a time-step-based Polars loop.</span>

<span class="sd">    This function orchestrates the autoregressive process by iterating</span>
<span class="sd">    through each unique, adjusted time step (`subsequenceIdAdjusted`).</span>

<span class="sd">    For each time step:</span>
<span class="sd">    1. Filters the main DataFrame `data` to get the current slice of data</span>
<span class="sd">       for all sequences at that time step.</span>
<span class="sd">    2. Calls `get_probs_preds` to generate predictions for this slice.</span>
<span class="sd">    3. Uses `fill_in_predictions_pl` to update the *main* `data` DataFrame,</span>
<span class="sd">       filling in the `np.inf` placeholders for the *next* time steps</span>
<span class="sd">       using the predictions just made.</span>
<span class="sd">    4. Collects the predictions and a corresponding sort key.</span>

<span class="sd">    After iterating through all time steps, it sorts all collected</span>
<span class="sd">    predictions based on the keys (sequenceId, subsequenceId) and returns</span>
<span class="sd">    the complete, ordered results.</span>

<span class="sd">    Args:</span>
<span class="sd">        config: The `InfererModel` configuration object.</span>
<span class="sd">        inferer: The initialized `Inferer` instance.</span>
<span class="sd">        data: The input Polars DataFrame, expanded with future rows</span>
<span class="sd">            (see `expand_data_by_autoregression`).</span>
<span class="sd">        column_types: A dictionary mapping column names to `torch.dtype`.</span>
<span class="sd">        seq_length: The sequence length, passed to `fill_in_predictions_pl`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple `(probs, preds, sequence_ids)`:</span>
<span class="sd">            - `probs`: A dictionary mapping target columns to sorted NumPy</span>
<span class="sd">              arrays of probabilities, or `None`.</span>
<span class="sd">            - `preds`: A dictionary mapping target columns to sorted NumPy</span>
<span class="sd">              arrays of final predictions.</span>
<span class="sd">            - `sequence_ids`: A NumPy array of `sequenceId`s corresponding</span>
<span class="sd">              to each row in the `preds` arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s2">&quot;sequenceId&quot;</span><span class="p">,</span> <span class="s2">&quot;subsequenceId&quot;</span><span class="p">)</span>
    <span class="n">verify_variable_order</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># Normalize subsequenceId to start from 0 for each sequence</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">with_columns</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;subsequenceId&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;subsequenceId&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="s2">&quot;sequenceId&quot;</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;subsequenceIdAdjusted&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">preds_list</span><span class="p">,</span> <span class="n">probs_list</span><span class="p">,</span> <span class="n">sort_keys</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">subsequence_ids_distinct</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;subsequenceIdAdjusted&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span>

    <span class="c1"># Ensure max_length for padding is robust for both sequence and subsequence IDs</span>
    <span class="n">max_id_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sequenceId&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
        <span class="nb">max</span><span class="p">(</span><span class="n">subsequence_ids_distinct</span><span class="p">)</span> <span class="k">if</span> <span class="n">subsequence_ids_distinct</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">max_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">max_id_val</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">subsequence_id</span> <span class="ow">in</span> <span class="n">subsequence_ids_distinct</span><span class="p">:</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="n">data_subset</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;subsequenceIdAdjusted&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">subsequence_id</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data_subset</span><span class="o">.</span><span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">sequence_ids_present</span> <span class="o">=</span> <span class="n">data_subset</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span><span class="s2">&quot;sequenceId&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="n">maintain_order</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

        <span class="c1"># Original sort key logic</span>
        <span class="n">sort_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fill_number</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">seq_id</span><span class="p">),</span><span class="w"> </span><span class="n">max_length</span><span class="p">)</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">fill_number</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">subsequence_id</span><span class="p">),</span><span class="w"> </span><span class="n">max_length</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">seq_id</span> <span class="ow">in</span> <span class="n">sequence_ids_present</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">t2</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

        <span class="n">probs</span><span class="p">,</span> <span class="n">preds</span> <span class="o">=</span> <span class="n">get_probs_preds</span><span class="p">(</span>
            <span class="n">config</span><span class="p">,</span>
            <span class="n">inferer</span><span class="p">,</span>
            <span class="n">data_subset</span><span class="p">,</span>
            <span class="n">column_types</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">t3</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

        <span class="n">preds_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">probs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">probs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span>

        <span class="c1"># Use new Polars-native function to fill predictions</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">fill_in_predictions_pl</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">preds</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">subsequence_id</span><span class="p">),</span>
            <span class="n">sequence_ids_present</span><span class="p">,</span>
            <span class="n">seq_length</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">t4</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;[DEBUG] Autoregression step </span><span class="si">{</span><span class="n">subsequence_id</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">subsequence_ids_distinct</span><span class="p">)</span><span class="si">}</span><span class="s2">: Total: </span><span class="si">{</span><span class="n">format_delta</span><span class="p">(</span><span class="n">t4</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s (Filter: </span><span class="si">{</span><span class="n">format_delta</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s, Infer: </span><span class="si">{</span><span class="n">format_delta</span><span class="p">(</span><span class="n">t3</span><span class="o">-</span><span class="n">t2</span><span class="p">)</span><span class="si">}</span><span class="s2">s, Update: </span><span class="si">{</span><span class="n">format_delta</span><span class="p">(</span><span class="n">t4</span><span class="o">-</span><span class="n">t3</span><span class="p">)</span><span class="si">}</span><span class="s2">s)&quot;</span>
        <span class="p">)</span>

    <span class="n">sort_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sort_keys</span><span class="p">)</span>

    <span class="n">preds</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">target_column</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">preds_list</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span>
            <span class="n">sort_order</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">target_column</span> <span class="ow">in</span> <span class="n">inferer</span><span class="o">.</span><span class="n">target_columns</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">probs_list</span><span class="p">):</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">target_column</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">probs_list</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)[</span><span class="n">sort_order</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">for</span> <span class="n">target_column</span> <span class="ow">in</span> <span class="n">inferer</span><span class="o">.</span><span class="n">target_columns</span>
        <span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Create the corresponding sequence_id array from the sorted keys</span>
    <span class="n">sorted_keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sort_keys</span><span class="p">)[</span><span class="n">sort_order</span><span class="p">]</span>
    <span class="n">sequence_ids_for_preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sorted_keys</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">probs</span><span class="p">,</span> <span class="n">preds</span><span class="p">,</span> <span class="n">sequence_ids_for_preds</span></div>



<div class="viewcode-block" id="Inferer">
<a class="viewcode-back" href="../../api.html#sequifier.infer.Inferer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Inferer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class for performing inference with a trained sequifier model.</span>

<span class="sd">    This class encapsulates the model (either ONNX session or PyTorch model),</span>
<span class="sd">    normalization statistics, ID mappings, and all configuration needed</span>
<span class="sd">    to run inference. It provides methods to handle batching, model-specific</span>
<span class="sd">    inference calls (PyTorch vs. ONNX), and post-processing</span>
<span class="sd">    (like inverting normalization).</span>

<span class="sd">    Attributes:</span>
<span class="sd">        model_type: &#39;generative&#39; or &#39;embedding&#39;.</span>
<span class="sd">        map_to_id: Whether to map integer predictions back to original IDs.</span>
<span class="sd">        selected_columns_statistics: Dict of &#39;mean&#39; and &#39;std&#39; for real columns.</span>
<span class="sd">        index_map: The inverse of `id_maps`, for mapping indices back to values.</span>
<span class="sd">        device: The device (&#39;cuda&#39; or &#39;cpu&#39;) for inference.</span>
<span class="sd">        target_columns: List of columns the model predicts.</span>
<span class="sd">        target_column_types: Dict mapping target columns to &#39;categorical&#39; or &#39;real&#39;.</span>
<span class="sd">        inference_model_type: &#39;onnx&#39; or &#39;pt&#39;.</span>
<span class="sd">        ort_session: `onnxruntime.InferenceSession` if using ONNX.</span>
<span class="sd">        inference_model: The loaded PyTorch model if using &#39;pt&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Inferer.__init__">
<a class="viewcode-back" href="../../api.html#sequifier.infer.Inferer.__init__">[docs]</a>
    <span class="nd">@beartype</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">model_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">project_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">id_maps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]],</span>
        <span class="n">selected_columns_statistics</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
        <span class="n">map_to_id</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">categorical_columns</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">real_columns</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">selected_columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">target_columns</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">target_column_types</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">sample_from_distribution_columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">infer_with_dropout</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">inference_batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">args_config</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">training_config_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the Inferer.</span>

<span class="sd">        Args:</span>
<span class="sd">            model_type: The type of model to use for inference.</span>
<span class="sd">            model_path: The path to the trained model.</span>
<span class="sd">            project_path: The path to the sequifier project directory.</span>
<span class="sd">            id_maps: A dictionary of id maps for categorical columns.</span>
<span class="sd">            selected_columns_statistics: A dictionary of statistics for numerical columns.</span>
<span class="sd">            map_to_id: Whether to map the output to the original ids.</span>
<span class="sd">            categorical_columns: A list of categorical columns.</span>
<span class="sd">            real_columns: A list of real columns.</span>
<span class="sd">            selected_columns: A list of selected columns.</span>
<span class="sd">            target_columns: A list of target columns.</span>
<span class="sd">            target_column_types: A dictionary of target column types.</span>
<span class="sd">            sample_from_distribution_columns: A list of columns to sample from the distribution.</span>
<span class="sd">            infer_with_dropout: Whether to use dropout during inference.</span>
<span class="sd">            inference_batch_size: The batch size for inference.</span>
<span class="sd">            device: The device to use for inference.</span>
<span class="sd">            args_config: The command-line arguments.</span>
<span class="sd">            training_config_path: The path to the training configuration file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">=</span> <span class="n">model_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_to_id</span> <span class="o">=</span> <span class="n">map_to_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selected_columns_statistics</span> <span class="o">=</span> <span class="n">selected_columns_statistics</span>
        <span class="n">target_columns_index_map</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">target_columns</span> <span class="k">if</span> <span class="n">target_column_types</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;categorical&quot;</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span> <span class="o">=</span> <span class="n">construct_index_maps</span><span class="p">(</span>
            <span class="n">id_maps</span><span class="p">,</span> <span class="n">target_columns_index_map</span><span class="p">,</span> <span class="n">map_to_id</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">categorical_columns</span> <span class="o">=</span> <span class="n">categorical_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_columns</span> <span class="o">=</span> <span class="n">real_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selected_columns</span> <span class="o">=</span> <span class="n">selected_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_columns</span> <span class="o">=</span> <span class="n">target_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_column_types</span> <span class="o">=</span> <span class="n">target_column_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_from_distribution_columns</span> <span class="o">=</span> <span class="n">sample_from_distribution_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infer_with_dropout</span> <span class="o">=</span> <span class="n">infer_with_dropout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inference_batch_size</span> <span class="o">=</span> <span class="n">inference_batch_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inference_model_type</span> <span class="o">=</span> <span class="n">model_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args_config</span> <span class="o">=</span> <span class="n">args_config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">training_config_path</span> <span class="o">=</span> <span class="n">training_config_path</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_model_type</span> <span class="o">==</span> <span class="s2">&quot;onnx&quot;</span><span class="p">:</span>
            <span class="n">execution_providers</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;CUDAExecutionProvider&quot;</span> <span class="k">if</span> <span class="n">device</span> <span class="o">==</span> <span class="s2">&quot;cuda&quot;</span> <span class="k">else</span> <span class="s2">&quot;CPUExecutionProvider&quot;</span>
            <span class="p">]</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_with_dropout</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;disabled_optimizers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;EliminateDropout&quot;</span><span class="p">]</span>

                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;For inference with onnx, &#39;infer_with_dropout==True&#39; is only effective if &#39;export_with_dropout==True&#39; in training&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">ort_session</span> <span class="o">=</span> <span class="n">onnxruntime</span><span class="o">.</span><span class="n">InferenceSession</span><span class="p">(</span>
                <span class="n">normalize_path</span><span class="p">(</span><span class="n">model_path</span><span class="p">,</span> <span class="n">project_path</span><span class="p">),</span>
                <span class="n">providers</span><span class="o">=</span><span class="n">execution_providers</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_model_type</span> <span class="o">==</span> <span class="s2">&quot;pt&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inference_model</span> <span class="o">=</span> <span class="n">load_inference_model</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span><span class="p">,</span>
                <span class="n">normalize_path</span><span class="p">(</span><span class="n">model_path</span><span class="p">,</span> <span class="n">project_path</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">training_config_path</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">args_config</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">infer_with_dropout</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Inferer.invert_normalization">
<a class="viewcode-back" href="../../api.html#sequifier.infer.Inferer.invert_normalization">[docs]</a>
    <span class="nd">@beartype</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">invert_normalization</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">target_column</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inverts Z-score normalization for a given target column.</span>

<span class="sd">        Uses the &#39;mean&#39; and &#39;std&#39; stored in `self.selected_columns_statistics`</span>
<span class="sd">        to transform normalized values back to their original scale.</span>

<span class="sd">        Args:</span>
<span class="sd">            values: A NumPy array of normalized values.</span>
<span class="sd">            target_column: The name of the column whose statistics should be</span>
<span class="sd">                used for the inverse transformation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A NumPy array of values in their original scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_columns_statistics</span><span class="p">[</span><span class="n">target_column</span><span class="p">][</span><span class="s2">&quot;std&quot;</span><span class="p">]</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_columns_statistics</span><span class="p">[</span><span class="n">target_column</span><span class="p">][</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">values</span> <span class="o">*</span> <span class="p">(</span><span class="n">std</span> <span class="o">-</span> <span class="mf">1e-9</span><span class="p">))</span> <span class="o">+</span> <span class="n">mean</span></div>


<div class="viewcode-block" id="Inferer.infer_embedding">
<a class="viewcode-back" href="../../api.html#sequifier.infer.Inferer.infer_embedding">[docs]</a>
    <span class="nd">@beartype</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">infer_embedding</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs inference with an embedding model.</span>

<span class="sd">        This is a high-level wrapper that calls</span>
<span class="sd">        `adjust_and_infer_embedding` to handle batching and model-specific</span>
<span class="sd">        logic.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: A dictionary mapping feature names to NumPy arrays. All arrays</span>
<span class="sd">               must have the same first dimension (batch size).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A 2D NumPy array of the resulting embeddings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">embedding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjust_and_infer_embedding</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">embedding</span></div>


<div class="viewcode-block" id="Inferer.infer_generative">
<a class="viewcode-back" href="../../api.html#sequifier.infer.Inferer.infer_generative">[docs]</a>
    <span class="nd">@beartype</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">infer_generative</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="n">probs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_probs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs generative inference, returning probabilities or predictions.</span>

<span class="sd">        This function orchestrates the generative inference process.</span>
<span class="sd">        1. If `probs` are not provided, it calls `adjust_and_infer_generative`</span>
<span class="sd">           to get the raw model output (logits or real values) using `x`.</span>
<span class="sd">        2. If `return_probs` is True:</span>
<span class="sd">           - It normalizes the logits for categorical columns to get</span>
<span class="sd">             probabilities (using `softmax`, implemented in `normalize`).</span>
<span class="sd">           - It returns a dictionary of probabilities (for categorical) and</span>
<span class="sd">             raw predicted values (for real).</span>
<span class="sd">        3. If `return_probs` is False (default):</span>
<span class="sd">           - It converts the model outputs (either from `x` or `probs`) into</span>
<span class="sd">             final predictions.</span>
<span class="sd">           - For categorical columns, it either takes the `argmax` or samples</span>
<span class="sd">             from the distribution (`sample_with_cumsum`).</span>
<span class="sd">           - For real columns, it returns the value as-is.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: A dictionary mapping feature names to NumPy arrays. Required</span>
<span class="sd">               if `probs` is not provided.</span>
<span class="sd">            probs: An optional dictionary of probabilities/logits. If provided,</span>
<span class="sd">                   this skips the model inference step.</span>
<span class="sd">            return_probs: If True, returns normalized probabilities for</span>
<span class="sd">                categorical targets. If False, returns final class</span>
<span class="sd">                predictions (via argmax or sampling).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary mapping target column names to NumPy arrays. The</span>
<span class="sd">            content of the arrays depends on `return_probs`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">probs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">probs</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">):</span>  <span class="c1"># type: ignore</span>
            <span class="k">assert</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">probs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">probs</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="p">):</span>  <span class="c1"># type: ignore</span>
                <span class="k">assert</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Not all keys in x are in probs - </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="w"> </span><span class="si">= }</span><span class="s2"> != </span><span class="si">{</span><span class="n">probs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="w"> </span><span class="si">= }</span><span class="s2">. Full inference is executed.&quot;</span>
                <span class="p">)</span>

            <span class="n">outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjust_and_infer_generative</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">target_column</span><span class="p">,</span> <span class="n">target_outs</span> <span class="ow">in</span> <span class="n">outs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">target_outs</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span> <span class="n">target_outs</span>

            <span class="k">if</span> <span class="n">return_probs</span><span class="p">:</span>
                <span class="n">preds</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">target_column</span><span class="p">:</span> <span class="n">outputs</span>
                    <span class="k">for</span> <span class="n">target_column</span><span class="p">,</span> <span class="n">outputs</span> <span class="ow">in</span> <span class="n">outs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_column_types</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;categorical&quot;</span>
                <span class="p">}</span>
                <span class="n">logits</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">target_column</span><span class="p">:</span> <span class="n">outputs</span>
                    <span class="k">for</span> <span class="n">target_column</span><span class="p">,</span> <span class="n">outputs</span> <span class="ow">in</span> <span class="n">outs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_column_types</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;categorical&quot;</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="p">{</span><span class="o">**</span><span class="n">preds</span><span class="p">,</span> <span class="o">**</span><span class="n">normalize</span><span class="p">(</span><span class="n">logits</span><span class="p">)}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">target_column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_column_types</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;categorical&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_from_distribution_columns</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="ow">or</span> <span class="n">target_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_from_distribution_columns</span>
                <span class="p">):</span>
                    <span class="n">outs</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">outs</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outs</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_with_cumsum</span><span class="p">(</span><span class="n">outs</span><span class="p">[</span><span class="n">target_column</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">outs</span></div>


<div class="viewcode-block" id="Inferer.adjust_and_infer_embedding">
<a class="viewcode-back" href="../../api.html#sequifier.infer.Inferer.adjust_and_infer_embedding">[docs]</a>
    <span class="nd">@beartype</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">adjust_and_infer_embedding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handles batching and backend-specific calls for embedding inference.</span>

<span class="sd">        This function prepares the input data `x` into batches using</span>
<span class="sd">        `prepare_inference_batches` and then calls the correct inference</span>
<span class="sd">        backend based on `self.inference_model_type` (.pt or .onnx).</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The complete dictionary of input features (NumPy arrays).</span>
<span class="sd">            size: The total number of samples in `x`, used to truncate</span>
<span class="sd">                any padding added for batching.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A NumPy array of embeddings, concatenated from all batches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_model_type</span> <span class="o">==</span> <span class="s2">&quot;onnx&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">x_adjusted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_inference_batches</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pad_to_batch_size</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">inference_batch_embeddings</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">infer_pure</span><span class="p">(</span><span class="n">x_sub</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="n">size</span><span class="p">]</span> <span class="k">for</span> <span class="n">x_sub</span> <span class="ow">in</span> <span class="n">x_adjusted</span>
            <span class="p">]</span>
            <span class="n">embeddings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">inference_batch_embeddings</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_model_type</span> <span class="o">==</span> <span class="s2">&quot;pt&quot;</span><span class="p">:</span>
            <span class="n">x_adjusted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_inference_batches</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pad_to_batch_size</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">embeddings</span> <span class="o">=</span> <span class="n">infer_with_embedding_model</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inference_model</span><span class="p">,</span>
                <span class="n">x_adjusted</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                <span class="n">size</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_columns</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;not possible&quot;</span>
        <span class="k">return</span> <span class="n">embeddings</span></div>


<div class="viewcode-block" id="Inferer.adjust_and_infer_generative">
<a class="viewcode-back" href="../../api.html#sequifier.infer.Inferer.adjust_and_infer_generative">[docs]</a>
    <span class="nd">@beartype</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">adjust_and_infer_generative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handles batching and backend-specific calls for generative inference.</span>

<span class="sd">        This function prepares the input data `x` into batches using</span>
<span class="sd">        `prepare_inference_batches` and then calls the correct inference</span>
<span class="sd">        backend based on `self.inference_model_type` (.pt or .onnx).</span>
<span class="sd">        It aggregates the results from all batches.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The complete dictionary of input features (NumPy arrays).</span>
<span class="sd">            size: The total number of samples in `x`, used to truncate</span>
<span class="sd">                any padding added for batching.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary mapping target column names to NumPy arrays of raw</span>
<span class="sd">            model outputs (logits or real values).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_model_type</span> <span class="o">==</span> <span class="s2">&quot;onnx&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">x_adjusted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_inference_batches</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pad_to_batch_size</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">out_subs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_pure</span><span class="p">(</span><span class="n">x_sub</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">x_sub</span> <span class="ow">in</span> <span class="n">x_adjusted</span>
            <span class="p">]</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">target_column</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">out_sub</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span> <span class="k">for</span> <span class="n">out_sub</span> <span class="ow">in</span> <span class="n">out_subs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)[:</span><span class="n">size</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">for</span> <span class="n">target_column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_columns</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_model_type</span> <span class="o">==</span> <span class="s2">&quot;pt&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">x_adjusted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_inference_batches</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pad_to_batch_size</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="n">infer_with_generative_model</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inference_model</span><span class="p">,</span>
                <span class="n">x_adjusted</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                <span class="n">size</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_columns</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># for type checking</span>

        <span class="k">return</span> <span class="n">outs</span></div>


<div class="viewcode-block" id="Inferer.prepare_inference_batches">
<a class="viewcode-back" href="../../api.html#sequifier.infer.Inferer.prepare_inference_batches">[docs]</a>
    <span class="nd">@beartype</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare_inference_batches</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">pad_to_batch_size</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Splits input data into batches for inference.</span>

<span class="sd">        This function takes a large dictionary of feature arrays and splits</span>
<span class="sd">        them into a list of smaller dictionaries (batches) of size</span>
<span class="sd">        `self.inference_batch_size`.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: A dictionary of feature arrays.</span>
<span class="sd">            pad_to_batch_size: If True (for ONNX), the last batch will be</span>
<span class="sd">                padded up to `self.inference_batch_size` by repeating</span>
<span class="sd">                samples. If False (for PyTorch), the last batch may be</span>
<span class="sd">                smaller.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of dictionaries, where each dictionary is a single batch</span>
<span class="sd">            ready for inference.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_batch_size</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_batch_size</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pad_to_batch_size</span><span class="p">:</span>
                <span class="n">x_expanded</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">col</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_to_batch_size</span><span class="p">(</span><span class="n">x_col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">x_col</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">x_expanded</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">starts</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_batch_size</span><span class="p">)</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inference_batch_size</span><span class="p">,</span>
                <span class="n">size</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_batch_size</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inference_batch_size</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="n">x_col</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="p">:]</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">x_col</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="n">xs</span></div>


<div class="viewcode-block" id="Inferer.infer_pure">
<a class="viewcode-back" href="../../api.html#sequifier.infer.Inferer.infer_pure">[docs]</a>
    <span class="nd">@beartype</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">infer_pure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs a single inference pass using the ONNX session.</span>

<span class="sd">        This function assumes `x` is already a single, correctly-sized</span>
<span class="sd">        batch. It formats the input dictionary to match the ONNX model&#39;s</span>
<span class="sd">        input names and executes `self.ort_session.run()`.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: A dictionary of feature arrays for a single batch. This</span>
<span class="sd">               batch *must* be of size `self.inference_batch_size`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of NumPy arrays, representing the raw outputs from the</span>
<span class="sd">            ONNX model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ort_inputs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">session_input</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_to_batch_size</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">session_input</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ort_session</span><span class="o">.</span><span class="n">get_inputs</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">categorical_columns</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_columns</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">}</span>
        <span class="n">ort_outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ort_session</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">ort_inputs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ort_outs</span></div>


<div class="viewcode-block" id="Inferer.expand_to_batch_size">
<a class="viewcode-back" href="../../api.html#sequifier.infer.Inferer.expand_to_batch_size">[docs]</a>
    <span class="nd">@beartype</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">expand_to_batch_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pads a NumPy array to match `self.inference_batch_size`.</span>

<span class="sd">        Repeats samples from `x` until the array&#39;s first dimension</span>
<span class="sd">        is equal to `self.inference_batch_size`.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The input NumPy array to pad.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new NumPy array of size `self.inference_batch_size` in the</span>
<span class="sd">            first dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">repetitions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_batch_size</span> <span class="o">//</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">filler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_batch_size</span> <span class="o">%</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">repetitions</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">filler</span><span class="p">,</span> <span class="p">:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="normalize">
<a class="viewcode-back" href="../../api.html#sequifier.infer.normalize">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize</span><span class="p">(</span><span class="n">outs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Applies the softmax function to a dictionary of logits.</span>

<span class="sd">    Converts raw model logits for categorical columns into probabilities</span>
<span class="sd">    that sum to 1.</span>

<span class="sd">    Args:</span>
<span class="sd">        outs: A dictionary mapping target column names to NumPy arrays</span>
<span class="sd">              of logits.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dictionary mapping the same target column names to NumPy arrays</span>
<span class="sd">        of probabilities.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normalizer</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">target_column</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">target_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">target_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">target_values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">target_column</span><span class="p">,</span> <span class="n">target_values</span> <span class="ow">in</span> <span class="n">outs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">target_column</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">target_values</span><span class="p">)</span> <span class="o">/</span> <span class="n">normalizer</span><span class="p">[</span><span class="n">target_column</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">target_column</span><span class="p">,</span> <span class="n">target_values</span> <span class="ow">in</span> <span class="n">outs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">probs</span></div>



<div class="viewcode-block" id="sample_with_cumsum">
<a class="viewcode-back" href="../../api.html#sequifier.infer.sample_with_cumsum">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sample_with_cumsum</span><span class="p">(</span><span class="n">probs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Samples from a probability distribution using the inverse CDF method.</span>

<span class="sd">    Takes an array of logits, computes the cumulative probability</span>
<span class="sd">    distribution, draws a random number `r` from [0, 1), and returns</span>
<span class="sd">    the index of the first class `i` where `cumsum[i] &gt; r`.</span>

<span class="sd">    Args:</span>
<span class="sd">        probs: A 2D NumPy array of *logits* (not normalized probabilities).</span>
<span class="sd">               Shape is (batch_size, num_classes).</span>

<span class="sd">    Returns:</span>
<span class="sd">        A 1D NumPy array of shape (batch_size,) containing the sampled</span>
<span class="sd">        class indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cumulative_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">probs</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">random_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">cumulative_probs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">random_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">random_threshold</span><span class="p">,</span> <span class="n">probs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">random_threshold</span> <span class="o">&lt;</span> <span class="n">cumulative_probs</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, Leon Luithlen
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=c719e115"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=46bd48cc"></script>
    </body>
</html>